package com.sap.sse.gwt.client.shared.settings;

import java.util.Iterator;
import java.util.List;

import com.google.gwt.core.client.GWT;
import com.google.gwt.json.client.JSONObject;
import com.google.gwt.json.client.JSONParser;
import com.google.gwt.json.client.JSONValue;
import com.sap.sse.common.settings.Settings;

/**
 * Represents a generic representation of settings. Its used as a layer between
 * {@link com.sap.sse.common.settings.Settings Settings} object and persistence layer.
 * 
 * @author Vladislav Chumak
 *
 */
public class StorableSettingsRepresentation {

    private final JSONObject internalSettingsRepresentation;

    /**
     * 
     * @param settingsJsonRepresentation
     *            The representation of settings generated by using {@link #asJson()}. May not
     *            be {@code null}.
     */
    public StorableSettingsRepresentation(JSONObject settingsJsonRepresentation) {
        this.internalSettingsRepresentation = settingsJsonRepresentation;
    }

    /**
     * 
     * @param settingsStringRepresentation
     *            The representation of settings generated by using {@link #asString()}. May
     *            not be {@code null}.
     */
    public StorableSettingsRepresentation(String settingsStringRepresentation) {
        this.internalSettingsRepresentation = (JSONObject) JSONParser.parseStrict(settingsStringRepresentation);
    }

    /**
     * 
     * @return The representation of settings as JSON. Cannot be {@code null}.
     */
    public JSONObject asJson() {
        return internalSettingsRepresentation;
    }

    /**
     * 
     * @return The representation of settings as String. Cannot be {@code null}.
     */
    public String asString() {
        if(internalSettingsRepresentation != null) {
            return internalSettingsRepresentation.toString();
        } else {
            return null;
        }
    }
    
    /**
     * Patches the settings tree with the new settings provided. The settings node with the provided path is going to be
     * created/replaced with the new settings.
     * 
     * @param root
     *            The root node of the settings tree
     * @param path
     *            The path of the node to create/update
     * @param newSettings
     *            The new settings with that the target node in the settings tree is going to be updated
     * @param pipelineLevel
     *            The scope of settings used for settings storage (e.g. User Settings, or Document Settings)
     * @return The patched storable settings representation
     */
    public static StorableSettingsRepresentation patchSettingsRepresentation(StorableSettingsRepresentation root,
            Iterable<String> path, StorableSettingsRepresentation newSettings) {
        JSONObject settingsAsJson;
        if(newSettings == null) {
            settingsAsJson = null;
        } else {
            settingsAsJson = newSettings.asJson();
            if(settingsAsJson != null && settingsAsJson.keySet().isEmpty()) {
                settingsAsJson = null;
            }
        }
        JSONObject patchedSettingsJsonRepresentation = patchJsonObject(root == null ? null : root.asJson(),
                path.iterator(), settingsAsJson);
        return new StorableSettingsRepresentation(patchedSettingsJsonRepresentation);
    }
    
    /**
     * Internal helper method for
     * {@link #patchSettingsRepresentation(StorableSettingsRepresentation, List, Settings, PipelineLevel)}
     * 
     * @param root
     * @param path
     * @param originalPath
     * @param newSettings
     * @param pipelineLevel
     * @return
     */
    private static JSONObject patchJsonObject(JSONObject root, final Iterator<String> path,
            final JSONObject newSettings) {
        if (!path.hasNext()) {
            return newSettings;
        }
        if (root == null) {
            root = new JSONObject();
        }
        String current = path.next();
        // we need to go further
        if (path.hasNext()) {
            boolean haskey = root.containsKey(current);
            if(haskey || newSettings != null) {
                // if (!haskey && newSettings == null) we have currently no settings on the path and there are no new settings,
                // so do not have to do anything
                JSONObject currentObject = null;
                JSONValue child = root.get(current);
                if (child != null) {
                    currentObject = child.isObject();
                    if (currentObject == null) {
                        GWT.log("Warning: replacing some subtree element that is wrong type!");
                    }
                }
                root.put(current, patchJsonObject(child.isObject(), path, newSettings));
            }
        } else {
            root.put(current, newSettings);
        }
        if(root.keySet().isEmpty()) {
            // If there aren't any settings in this path, we just remove the whole path
            root = null;
        }
        return root;
    }
    
    public StorableSettingsRepresentation getSubSettingsRepresentation(Iterable<String> subPath) {
        return new StorableSettingsRepresentation(getSubSettingsRepresentation(internalSettingsRepresentation, subPath.iterator()));
    }
    
    public static JSONObject getSubSettingsRepresentation(JSONObject root, Iterator<String> subPath) {
        if (root == null || !subPath.hasNext()) {
            return root;
        } else {
            String current = subPath.next();
            // we need to go further
            JSONValue child = root.get(current);
            boolean haskey = root.containsKey(current);
            if (child == null || child.isObject() == null) {
                if (haskey) {
                    GWT.log("Warning: replacing some subtree element that is wrong type!");
                }
                child = new JSONObject();
            }
            return getSubSettingsRepresentation(child.isObject(), subPath);
        }
    }

}
